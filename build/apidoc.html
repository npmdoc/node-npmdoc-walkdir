<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://github.com/soldair/node-walkdir"

    >walkdir (v0.0.11)</a>
</h1>
<h4>Find files simply. Walks a directory tree emitting events based on what it finds. Presents a familiar callback/emitter/a+sync interface. Walk a tree of any depth.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.walkdir">module walkdir</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.walkdir.walkdir">
            function <span class="apidocSignatureSpan"></span>walkdir
            <span class="apidocSignatureSpan">(path, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.walkdir.find">
            function <span class="apidocSignatureSpan">walkdir.</span>find
            <span class="apidocSignatureSpan">(path, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.walkdir.sync">
            function <span class="apidocSignatureSpan">walkdir.</span>sync
            <span class="apidocSignatureSpan">(path, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.walkdir.walk">
            function <span class="apidocSignatureSpan">walkdir.</span>walk
            <span class="apidocSignatureSpan">(path, options, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.walkdir.walk">module walkdir.walk</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.walkdir.walk.walk">
            function <span class="apidocSignatureSpan">walkdir.</span>walk
            <span class="apidocSignatureSpan">(path, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.walkdir.walk.find">
            function <span class="apidocSignatureSpan">walkdir.walk.</span>find
            <span class="apidocSignatureSpan">(path, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.walkdir.walk.sync">
            function <span class="apidocSignatureSpan">walkdir.walk.</span>sync
            <span class="apidocSignatureSpan">(path, options, cb)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.walkdir" id="apidoc.module.walkdir">module walkdir</a></h1>


    <h2>
        <a href="#apidoc.element.walkdir.walkdir" id="apidoc.element.walkdir.walkdir">
        function <span class="apidocSignatureSpan"></span>walkdir
        <span class="apidocSignatureSpan">(path, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkdir(path, options, cb){

  if(typeof options == &#x27;function&#x27;) cb = options;

  options = options || {};

  var fs = options.fs || _fs;

  var emitter = new EventEmitter(),
  dontTraverse = [],
  allPaths = (options.return_object?{}:[]),
  resolved = false,
  inos = {},
  stop = 0,
  pause = null,
  ended = 0,
  jobs=0,
  job = function(value) {
    jobs += value;
    if(value &#x3c; 1 &#x26;&#x26; !tick) {
      tick = 1;
      process.nextTick(function(){
        tick = 0;
        if(jobs &#x3c;= 0 &#x26;&#x26; !ended) {
          ended = 1;
          emitter.emit(&#x27;end&#x27;);
        }
      });
    }
  }, tick = 0;

  emitter.ignore = function(path){
    if(Array.isArray(path)) dontTraverse.push.apply(dontTraverse,path)
    else dontTraverse.push(path)
    return this
  }

  //mapping is stat functions to event names.	
  var statIs = [[&#x27;isFile&#x27;,&#x27;file&#x27;],[&#x27;isDirectory&#x27;,&#x27;directory&#x27;],[&#x27;isSymbolicLink&#x27;,&#x27;link&#x27;],[&#x27;isSocket&#x27;,&#x27;socket&#x27;],[&#x27;isFIFO&#x27;,&#x27;fifo&#x27;],[&#x27;
isBlockDevice&#x27;,&#x27;blockdevice&#x27;],[&#x27;isCharacterDevice&#x27;,&#x27;characterdevice&#x27;]];

  var statter = function (path,first,depth) {
    job(1);
    var statAction = function fn(err,stat,data) {

      job(-1);
      if(stop) return;

      // in sync mode i found that node will sometimes return a null stat and no error =(
      // this is reproduceable in file descriptors that no longer exist from this process
      // after a readdir on /proc/3321/task/3321/ for example. Where 3321 is this pid
      // node @ v0.6.10
      if(err || !stat) {
        emitter.emit(&#x27;fail&#x27;,path,err);
        return;
      }


      //if i have evented this inode already dont again.
      var fileName = _path.basename(path);
      var fileKey = stat.dev + &#x27;-&#x27; + stat.ino + &#x27;-&#x27; + fileName;
      if(inos[fileKey] &#x26;&#x26; stat.ino) return;
      inos[fileKey] = 1;

      if (first &#x26;&#x26; stat.isDirectory()) {
        emitter.emit(&#x27;targetdirectory&#x27;,path,stat,depth);
        return;
      }

      emitter.emit(&#x27;path&#x27;, path, stat,depth);

      var i,name;

      for(var j=0,k=statIs.length;j&#x3c;k;j++) {
        if(stat[statIs[j][0]]()) {
          emitter.emit(statIs[j][1],path,stat,depth);
          break;
        }
      }
    };

    if(options.sync) {
      var stat,ex;
      try{
        stat = fs.lstatSync(path);
      } catch (e) {
        ex = e;
      }

      statAction(ex,stat);
    } else {
        fs.lstat(path,statAction);
    }
  },readdir = function(path,stat,depth){
    if(!resolved) {
      path = _path.resolve(path);
      resolved = 1;
    }

    if(options.max_depth &#x26;&#x26; depth &#x3e;= options.max_depth){
      emitter.emit(&#x27;maxdepth&#x27;,path,stat,depth);
      return;
    }

    if(dontTraverse.length){
      for(var i=0;i&#x3c;dontTraverse.length;++i){
        if(dontTraverse[i] == path) {
          dontTraverse.splice(i,1)
          return;
        }
      }
    }

    job(1);
    var readdirAction = function(err,files) {
      job(-1);
      if (err || !files) {
        //permissions error or invalid files
        emitter.emit(&#x27;fail&#x27;,path,err);
        return;
      }

      if(!files.length) {
        // empty directory event.
        emitter.emit(&#x27;empty&#x27;,path,stat,depth);
        return;
      }

      if(path == sep) path=&#x27;&#x27;;
      for(var i=0,j=files.length;i&#x3c;j;i++){
        statter(path+sep+files[i],false,(depth||0)+1);
      }

    };


    //use same pattern for sync as async api
    if(options.sync) {
      var e,files;
      try {
          files = fs.readdirSync(path);
      } catch (e) { }

      readdirAction(e,files);
    } else {
      fs.readdir(path,readdirAction);
    }
  };

  if (options.follow_symlinks) {
    var linkAction = function(err,path,depth){
      job(-1);
      //TODO should fail event here on error?
      statter(path,false,depth);
    };

    emitter.on(&#x27;link&#x27;,function(path,stat,depth){
      job(1);
      if(options.sync) {
        var lpath,ex;
        try {
          lpath = fs.readlinkSync(path);
        } catch(e) {
          ex = e;
        }
        linkAction(ex,_path.resolve(_path.dirname(path),lpath),depth);

      } else {
        fs.readlink(path,function(err,lpath){
          linkAc ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.walkdir.find" id="apidoc.element.walkdir.find">
        function <span class="apidocSignatureSpan">walkdir.</span>find
        <span class="apidocSignatureSpan">(path, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkdir(path, options, cb){

  if(typeof options == &#x27;function&#x27;) cb = options;

  options = options || {};

  var fs = options.fs || _fs;

  var emitter = new EventEmitter(),
  dontTraverse = [],
  allPaths = (options.return_object?{}:[]),
  resolved = false,
  inos = {},
  stop = 0,
  pause = null,
  ended = 0,
  jobs=0,
  job = function(value) {
    jobs += value;
    if(value &#x3c; 1 &#x26;&#x26; !tick) {
      tick = 1;
      process.nextTick(function(){
        tick = 0;
        if(jobs &#x3c;= 0 &#x26;&#x26; !ended) {
          ended = 1;
          emitter.emit(&#x27;end&#x27;);
        }
      });
    }
  }, tick = 0;

  emitter.ignore = function(path){
    if(Array.isArray(path)) dontTraverse.push.apply(dontTraverse,path)
    else dontTraverse.push(path)
    return this
  }

  //mapping is stat functions to event names.	
  var statIs = [[&#x27;isFile&#x27;,&#x27;file&#x27;],[&#x27;isDirectory&#x27;,&#x27;directory&#x27;],[&#x27;isSymbolicLink&#x27;,&#x27;link&#x27;],[&#x27;isSocket&#x27;,&#x27;socket&#x27;],[&#x27;isFIFO&#x27;,&#x27;fifo&#x27;],[&#x27;
isBlockDevice&#x27;,&#x27;blockdevice&#x27;],[&#x27;isCharacterDevice&#x27;,&#x27;characterdevice&#x27;]];

  var statter = function (path,first,depth) {
    job(1);
    var statAction = function fn(err,stat,data) {

      job(-1);
      if(stop) return;

      // in sync mode i found that node will sometimes return a null stat and no error =(
      // this is reproduceable in file descriptors that no longer exist from this process
      // after a readdir on /proc/3321/task/3321/ for example. Where 3321 is this pid
      // node @ v0.6.10
      if(err || !stat) {
        emitter.emit(&#x27;fail&#x27;,path,err);
        return;
      }


      //if i have evented this inode already dont again.
      var fileName = _path.basename(path);
      var fileKey = stat.dev + &#x27;-&#x27; + stat.ino + &#x27;-&#x27; + fileName;
      if(inos[fileKey] &#x26;&#x26; stat.ino) return;
      inos[fileKey] = 1;

      if (first &#x26;&#x26; stat.isDirectory()) {
        emitter.emit(&#x27;targetdirectory&#x27;,path,stat,depth);
        return;
      }

      emitter.emit(&#x27;path&#x27;, path, stat,depth);

      var i,name;

      for(var j=0,k=statIs.length;j&#x3c;k;j++) {
        if(stat[statIs[j][0]]()) {
          emitter.emit(statIs[j][1],path,stat,depth);
          break;
        }
      }
    };

    if(options.sync) {
      var stat,ex;
      try{
        stat = fs.lstatSync(path);
      } catch (e) {
        ex = e;
      }

      statAction(ex,stat);
    } else {
        fs.lstat(path,statAction);
    }
  },readdir = function(path,stat,depth){
    if(!resolved) {
      path = _path.resolve(path);
      resolved = 1;
    }

    if(options.max_depth &#x26;&#x26; depth &#x3e;= options.max_depth){
      emitter.emit(&#x27;maxdepth&#x27;,path,stat,depth);
      return;
    }

    if(dontTraverse.length){
      for(var i=0;i&#x3c;dontTraverse.length;++i){
        if(dontTraverse[i] == path) {
          dontTraverse.splice(i,1)
          return;
        }
      }
    }

    job(1);
    var readdirAction = function(err,files) {
      job(-1);
      if (err || !files) {
        //permissions error or invalid files
        emitter.emit(&#x27;fail&#x27;,path,err);
        return;
      }

      if(!files.length) {
        // empty directory event.
        emitter.emit(&#x27;empty&#x27;,path,stat,depth);
        return;
      }

      if(path == sep) path=&#x27;&#x27;;
      for(var i=0,j=files.length;i&#x3c;j;i++){
        statter(path+sep+files[i],false,(depth||0)+1);
      }

    };


    //use same pattern for sync as async api
    if(options.sync) {
      var e,files;
      try {
          files = fs.readdirSync(path);
      } catch (e) { }

      readdirAction(e,files);
    } else {
      fs.readdir(path,readdirAction);
    }
  };

  if (options.follow_symlinks) {
    var linkAction = function(err,path,depth){
      job(-1);
      //TODO should fail event here on error?
      statter(path,false,depth);
    };

    emitter.on(&#x27;link&#x27;,function(path,stat,depth){
      job(1);
      if(options.sync) {
        var lpath,ex;
        try {
          lpath = fs.readlinkSync(path);
        } catch(e) {
          ex = e;
        }
        linkAction(ex,_path.resolve(_path.dirname(path),lpath),depth);

      } else {
        fs.readlink(path,function(err,lpath){
          linkAc ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.walkdir.sync" id="apidoc.element.walkdir.sync">
        function <span class="apidocSignatureSpan">walkdir.</span>sync
        <span class="apidocSignatureSpan">(path, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sync = function (path, options, cb){
  if(typeof options == &#x27;function&#x27;) cb = options;
  options = options || {};
  options.sync = true;
  return walkdir(path,options,cb);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
emitter.on(&#x27;file&#x27;,function(filename,stat){
  console.log(&#x27;file from emitter: &#x27;, filename);
});


//sync with callback

walk.<span class="apidocCodeKeywordSpan">sync</span>(&#x27;../&#x27;,function(path,stat){
  console.log(&#x27;found sync:&#x27;,path);
});

//sync just need paths

var paths = walk.sync(&#x27;../&#x27;);
console.log(&#x27;found paths sync: &#x27;,paths);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.walkdir.walk" id="apidoc.element.walkdir.walk">
        function <span class="apidocSignatureSpan">walkdir.</span>walk
        <span class="apidocSignatureSpan">(path, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkdir(path, options, cb){

  if(typeof options == &#x27;function&#x27;) cb = options;

  options = options || {};

  var fs = options.fs || _fs;

  var emitter = new EventEmitter(),
  dontTraverse = [],
  allPaths = (options.return_object?{}:[]),
  resolved = false,
  inos = {},
  stop = 0,
  pause = null,
  ended = 0,
  jobs=0,
  job = function(value) {
    jobs += value;
    if(value &#x3c; 1 &#x26;&#x26; !tick) {
      tick = 1;
      process.nextTick(function(){
        tick = 0;
        if(jobs &#x3c;= 0 &#x26;&#x26; !ended) {
          ended = 1;
          emitter.emit(&#x27;end&#x27;);
        }
      });
    }
  }, tick = 0;

  emitter.ignore = function(path){
    if(Array.isArray(path)) dontTraverse.push.apply(dontTraverse,path)
    else dontTraverse.push(path)
    return this
  }

  //mapping is stat functions to event names.	
  var statIs = [[&#x27;isFile&#x27;,&#x27;file&#x27;],[&#x27;isDirectory&#x27;,&#x27;directory&#x27;],[&#x27;isSymbolicLink&#x27;,&#x27;link&#x27;],[&#x27;isSocket&#x27;,&#x27;socket&#x27;],[&#x27;isFIFO&#x27;,&#x27;fifo&#x27;],[&#x27;
isBlockDevice&#x27;,&#x27;blockdevice&#x27;],[&#x27;isCharacterDevice&#x27;,&#x27;characterdevice&#x27;]];

  var statter = function (path,first,depth) {
    job(1);
    var statAction = function fn(err,stat,data) {

      job(-1);
      if(stop) return;

      // in sync mode i found that node will sometimes return a null stat and no error =(
      // this is reproduceable in file descriptors that no longer exist from this process
      // after a readdir on /proc/3321/task/3321/ for example. Where 3321 is this pid
      // node @ v0.6.10
      if(err || !stat) {
        emitter.emit(&#x27;fail&#x27;,path,err);
        return;
      }


      //if i have evented this inode already dont again.
      var fileName = _path.basename(path);
      var fileKey = stat.dev + &#x27;-&#x27; + stat.ino + &#x27;-&#x27; + fileName;
      if(inos[fileKey] &#x26;&#x26; stat.ino) return;
      inos[fileKey] = 1;

      if (first &#x26;&#x26; stat.isDirectory()) {
        emitter.emit(&#x27;targetdirectory&#x27;,path,stat,depth);
        return;
      }

      emitter.emit(&#x27;path&#x27;, path, stat,depth);

      var i,name;

      for(var j=0,k=statIs.length;j&#x3c;k;j++) {
        if(stat[statIs[j][0]]()) {
          emitter.emit(statIs[j][1],path,stat,depth);
          break;
        }
      }
    };

    if(options.sync) {
      var stat,ex;
      try{
        stat = fs.lstatSync(path);
      } catch (e) {
        ex = e;
      }

      statAction(ex,stat);
    } else {
        fs.lstat(path,statAction);
    }
  },readdir = function(path,stat,depth){
    if(!resolved) {
      path = _path.resolve(path);
      resolved = 1;
    }

    if(options.max_depth &#x26;&#x26; depth &#x3e;= options.max_depth){
      emitter.emit(&#x27;maxdepth&#x27;,path,stat,depth);
      return;
    }

    if(dontTraverse.length){
      for(var i=0;i&#x3c;dontTraverse.length;++i){
        if(dontTraverse[i] == path) {
          dontTraverse.splice(i,1)
          return;
        }
      }
    }

    job(1);
    var readdirAction = function(err,files) {
      job(-1);
      if (err || !files) {
        //permissions error or invalid files
        emitter.emit(&#x27;fail&#x27;,path,err);
        return;
      }

      if(!files.length) {
        // empty directory event.
        emitter.emit(&#x27;empty&#x27;,path,stat,depth);
        return;
      }

      if(path == sep) path=&#x27;&#x27;;
      for(var i=0,j=files.length;i&#x3c;j;i++){
        statter(path+sep+files[i],false,(depth||0)+1);
      }

    };


    //use same pattern for sync as async api
    if(options.sync) {
      var e,files;
      try {
          files = fs.readdirSync(path);
      } catch (e) { }

      readdirAction(e,files);
    } else {
      fs.readdir(path,readdirAction);
    }
  };

  if (options.follow_symlinks) {
    var linkAction = function(err,path,depth){
      job(-1);
      //TODO should fail event here on error?
      statter(path,false,depth);
    };

    emitter.on(&#x27;link&#x27;,function(path,stat,depth){
      job(1);
      if(options.sync) {
        var lpath,ex;
        try {
          lpath = fs.readlinkSync(path);
        } catch(e) {
          ex = e;
        }
        linkAction(ex,_path.resolve(_path.dirname(path),lpath),depth);

      } else {
        fs.readlink(path,function(err,lpath){
          linkAc ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.walkdir.walk" id="apidoc.module.walkdir.walk">module walkdir.walk</a></h1>


    <h2>
        <a href="#apidoc.element.walkdir.walk.walk" id="apidoc.element.walkdir.walk.walk">
        function <span class="apidocSignatureSpan">walkdir.</span>walk
        <span class="apidocSignatureSpan">(path, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkdir(path, options, cb){

  if(typeof options == &#x27;function&#x27;) cb = options;

  options = options || {};

  var fs = options.fs || _fs;

  var emitter = new EventEmitter(),
  dontTraverse = [],
  allPaths = (options.return_object?{}:[]),
  resolved = false,
  inos = {},
  stop = 0,
  pause = null,
  ended = 0,
  jobs=0,
  job = function(value) {
    jobs += value;
    if(value &#x3c; 1 &#x26;&#x26; !tick) {
      tick = 1;
      process.nextTick(function(){
        tick = 0;
        if(jobs &#x3c;= 0 &#x26;&#x26; !ended) {
          ended = 1;
          emitter.emit(&#x27;end&#x27;);
        }
      });
    }
  }, tick = 0;

  emitter.ignore = function(path){
    if(Array.isArray(path)) dontTraverse.push.apply(dontTraverse,path)
    else dontTraverse.push(path)
    return this
  }

  //mapping is stat functions to event names.	
  var statIs = [[&#x27;isFile&#x27;,&#x27;file&#x27;],[&#x27;isDirectory&#x27;,&#x27;directory&#x27;],[&#x27;isSymbolicLink&#x27;,&#x27;link&#x27;],[&#x27;isSocket&#x27;,&#x27;socket&#x27;],[&#x27;isFIFO&#x27;,&#x27;fifo&#x27;],[&#x27;
isBlockDevice&#x27;,&#x27;blockdevice&#x27;],[&#x27;isCharacterDevice&#x27;,&#x27;characterdevice&#x27;]];

  var statter = function (path,first,depth) {
    job(1);
    var statAction = function fn(err,stat,data) {

      job(-1);
      if(stop) return;

      // in sync mode i found that node will sometimes return a null stat and no error =(
      // this is reproduceable in file descriptors that no longer exist from this process
      // after a readdir on /proc/3321/task/3321/ for example. Where 3321 is this pid
      // node @ v0.6.10
      if(err || !stat) {
        emitter.emit(&#x27;fail&#x27;,path,err);
        return;
      }


      //if i have evented this inode already dont again.
      var fileName = _path.basename(path);
      var fileKey = stat.dev + &#x27;-&#x27; + stat.ino + &#x27;-&#x27; + fileName;
      if(inos[fileKey] &#x26;&#x26; stat.ino) return;
      inos[fileKey] = 1;

      if (first &#x26;&#x26; stat.isDirectory()) {
        emitter.emit(&#x27;targetdirectory&#x27;,path,stat,depth);
        return;
      }

      emitter.emit(&#x27;path&#x27;, path, stat,depth);

      var i,name;

      for(var j=0,k=statIs.length;j&#x3c;k;j++) {
        if(stat[statIs[j][0]]()) {
          emitter.emit(statIs[j][1],path,stat,depth);
          break;
        }
      }
    };

    if(options.sync) {
      var stat,ex;
      try{
        stat = fs.lstatSync(path);
      } catch (e) {
        ex = e;
      }

      statAction(ex,stat);
    } else {
        fs.lstat(path,statAction);
    }
  },readdir = function(path,stat,depth){
    if(!resolved) {
      path = _path.resolve(path);
      resolved = 1;
    }

    if(options.max_depth &#x26;&#x26; depth &#x3e;= options.max_depth){
      emitter.emit(&#x27;maxdepth&#x27;,path,stat,depth);
      return;
    }

    if(dontTraverse.length){
      for(var i=0;i&#x3c;dontTraverse.length;++i){
        if(dontTraverse[i] == path) {
          dontTraverse.splice(i,1)
          return;
        }
      }
    }

    job(1);
    var readdirAction = function(err,files) {
      job(-1);
      if (err || !files) {
        //permissions error or invalid files
        emitter.emit(&#x27;fail&#x27;,path,err);
        return;
      }

      if(!files.length) {
        // empty directory event.
        emitter.emit(&#x27;empty&#x27;,path,stat,depth);
        return;
      }

      if(path == sep) path=&#x27;&#x27;;
      for(var i=0,j=files.length;i&#x3c;j;i++){
        statter(path+sep+files[i],false,(depth||0)+1);
      }

    };


    //use same pattern for sync as async api
    if(options.sync) {
      var e,files;
      try {
          files = fs.readdirSync(path);
      } catch (e) { }

      readdirAction(e,files);
    } else {
      fs.readdir(path,readdirAction);
    }
  };

  if (options.follow_symlinks) {
    var linkAction = function(err,path,depth){
      job(-1);
      //TODO should fail event here on error?
      statter(path,false,depth);
    };

    emitter.on(&#x27;link&#x27;,function(path,stat,depth){
      job(1);
      if(options.sync) {
        var lpath,ex;
        try {
          lpath = fs.readlinkSync(path);
        } catch(e) {
          ex = e;
        }
        linkAction(ex,_path.resolve(_path.dirname(path),lpath),depth);

      } else {
        fs.readlink(path,function(err,lpath){
          linkAc ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.walkdir.walk.find" id="apidoc.element.walkdir.walk.find">
        function <span class="apidocSignatureSpan">walkdir.walk.</span>find
        <span class="apidocSignatureSpan">(path, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkdir(path, options, cb){

  if(typeof options == &#x27;function&#x27;) cb = options;

  options = options || {};

  var fs = options.fs || _fs;

  var emitter = new EventEmitter(),
  dontTraverse = [],
  allPaths = (options.return_object?{}:[]),
  resolved = false,
  inos = {},
  stop = 0,
  pause = null,
  ended = 0,
  jobs=0,
  job = function(value) {
    jobs += value;
    if(value &#x3c; 1 &#x26;&#x26; !tick) {
      tick = 1;
      process.nextTick(function(){
        tick = 0;
        if(jobs &#x3c;= 0 &#x26;&#x26; !ended) {
          ended = 1;
          emitter.emit(&#x27;end&#x27;);
        }
      });
    }
  }, tick = 0;

  emitter.ignore = function(path){
    if(Array.isArray(path)) dontTraverse.push.apply(dontTraverse,path)
    else dontTraverse.push(path)
    return this
  }

  //mapping is stat functions to event names.	
  var statIs = [[&#x27;isFile&#x27;,&#x27;file&#x27;],[&#x27;isDirectory&#x27;,&#x27;directory&#x27;],[&#x27;isSymbolicLink&#x27;,&#x27;link&#x27;],[&#x27;isSocket&#x27;,&#x27;socket&#x27;],[&#x27;isFIFO&#x27;,&#x27;fifo&#x27;],[&#x27;
isBlockDevice&#x27;,&#x27;blockdevice&#x27;],[&#x27;isCharacterDevice&#x27;,&#x27;characterdevice&#x27;]];

  var statter = function (path,first,depth) {
    job(1);
    var statAction = function fn(err,stat,data) {

      job(-1);
      if(stop) return;

      // in sync mode i found that node will sometimes return a null stat and no error =(
      // this is reproduceable in file descriptors that no longer exist from this process
      // after a readdir on /proc/3321/task/3321/ for example. Where 3321 is this pid
      // node @ v0.6.10
      if(err || !stat) {
        emitter.emit(&#x27;fail&#x27;,path,err);
        return;
      }


      //if i have evented this inode already dont again.
      var fileName = _path.basename(path);
      var fileKey = stat.dev + &#x27;-&#x27; + stat.ino + &#x27;-&#x27; + fileName;
      if(inos[fileKey] &#x26;&#x26; stat.ino) return;
      inos[fileKey] = 1;

      if (first &#x26;&#x26; stat.isDirectory()) {
        emitter.emit(&#x27;targetdirectory&#x27;,path,stat,depth);
        return;
      }

      emitter.emit(&#x27;path&#x27;, path, stat,depth);

      var i,name;

      for(var j=0,k=statIs.length;j&#x3c;k;j++) {
        if(stat[statIs[j][0]]()) {
          emitter.emit(statIs[j][1],path,stat,depth);
          break;
        }
      }
    };

    if(options.sync) {
      var stat,ex;
      try{
        stat = fs.lstatSync(path);
      } catch (e) {
        ex = e;
      }

      statAction(ex,stat);
    } else {
        fs.lstat(path,statAction);
    }
  },readdir = function(path,stat,depth){
    if(!resolved) {
      path = _path.resolve(path);
      resolved = 1;
    }

    if(options.max_depth &#x26;&#x26; depth &#x3e;= options.max_depth){
      emitter.emit(&#x27;maxdepth&#x27;,path,stat,depth);
      return;
    }

    if(dontTraverse.length){
      for(var i=0;i&#x3c;dontTraverse.length;++i){
        if(dontTraverse[i] == path) {
          dontTraverse.splice(i,1)
          return;
        }
      }
    }

    job(1);
    var readdirAction = function(err,files) {
      job(-1);
      if (err || !files) {
        //permissions error or invalid files
        emitter.emit(&#x27;fail&#x27;,path,err);
        return;
      }

      if(!files.length) {
        // empty directory event.
        emitter.emit(&#x27;empty&#x27;,path,stat,depth);
        return;
      }

      if(path == sep) path=&#x27;&#x27;;
      for(var i=0,j=files.length;i&#x3c;j;i++){
        statter(path+sep+files[i],false,(depth||0)+1);
      }

    };


    //use same pattern for sync as async api
    if(options.sync) {
      var e,files;
      try {
          files = fs.readdirSync(path);
      } catch (e) { }

      readdirAction(e,files);
    } else {
      fs.readdir(path,readdirAction);
    }
  };

  if (options.follow_symlinks) {
    var linkAction = function(err,path,depth){
      job(-1);
      //TODO should fail event here on error?
      statter(path,false,depth);
    };

    emitter.on(&#x27;link&#x27;,function(path,stat,depth){
      job(1);
      if(options.sync) {
        var lpath,ex;
        try {
          lpath = fs.readlinkSync(path);
        } catch(e) {
          ex = e;
        }
        linkAction(ex,_path.resolve(_path.dirname(path),lpath),depth);

      } else {
        fs.readlink(path,function(err,lpath){
          linkAc ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.walkdir.walk.sync" id="apidoc.element.walkdir.walk.sync">
        function <span class="apidocSignatureSpan">walkdir.walk.</span>sync
        <span class="apidocSignatureSpan">(path, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sync = function (path, options, cb){
  if(typeof options == &#x27;function&#x27;) cb = options;
  options = options || {};
  options.sync = true;
  return walkdir(path,options,cb);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
emitter.on(&#x27;file&#x27;,function(filename,stat){
  console.log(&#x27;file from emitter: &#x27;, filename);
});


//sync with callback

walk.<span class="apidocCodeKeywordSpan">sync</span>(&#x27;../&#x27;,function(path,stat){
  console.log(&#x27;found sync:&#x27;,path);
});

//sync just need paths

var paths = walk.sync(&#x27;../&#x27;);
console.log(&#x27;found paths sync: &#x27;,paths);
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
