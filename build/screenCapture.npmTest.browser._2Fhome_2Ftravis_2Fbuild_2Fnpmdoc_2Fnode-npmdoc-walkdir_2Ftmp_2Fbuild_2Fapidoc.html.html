<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://github.com/soldair/node-walkdir">walkdir (v0.0.11)</a>
</h1>
<h4>Find files simply. Walks a directory tree emitting events based on what it finds. Presents a familiar callback/emitter/a+sync interface. Walk a tree of any depth.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.walkdir">module walkdir</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.walkdir.find">
            function <span class="apidocSignatureSpan">walkdir.</span>find
            <span class="apidocSignatureSpan">(path, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.walkdir.sync">
            function <span class="apidocSignatureSpan">walkdir.</span>sync
            <span class="apidocSignatureSpan">(path, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.walkdir.walk">
            function <span class="apidocSignatureSpan">walkdir.</span>walk
            <span class="apidocSignatureSpan">(path, options, cb)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.walkdir" id="apidoc.module.walkdir">module walkdir</a></h1>


    <h2>
        <a href="#apidoc.element.walkdir.find" id="apidoc.element.walkdir.find">
        function <span class="apidocSignatureSpan">walkdir.</span>find
        <span class="apidocSignatureSpan">(path, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkdir(path, options, cb){

  if(typeof options == 'function') cb = options;

  options = options || {};

  var fs = options.fs || _fs;

  var emitter = new EventEmitter(),
  dontTraverse = [],
  allPaths = (options.return_object?{}:[]),
  resolved = false,
  inos = {},
  stop = 0,
  pause = null,
  ended = 0,
  jobs=0,
  job = function(value) {
    jobs += value;
    if(value &lt; 1 &amp;&amp; !tick) {
      tick = 1;
      process.nextTick(function(){
        tick = 0;
        if(jobs &lt;= 0 &amp;&amp; !ended) {
          ended = 1;
          emitter.emit('end');
        }
      });
    }
  }, tick = 0;

  emitter.ignore = function(path){
    if(Array.isArray(path)) dontTraverse.push.apply(dontTraverse,path)
    else dontTraverse.push(path)
    return this
  }

  //mapping is stat functions to event names.	
  var statIs = [['isFile','file'],['isDirectory','directory'],['isSymbolicLink','link'],['isSocket','socket'],['isFIFO','fifo'],['
isBlockDevice','blockdevice'],['isCharacterDevice','characterdevice']];

  var statter = function (path,first,depth) {
    job(1);
    var statAction = function fn(err,stat,data) {

      job(-1);
      if(stop) return;

      // in sync mode i found that node will sometimes return a null stat and no error =(
      // this is reproduceable in file descriptors that no longer exist from this process
      // after a readdir on /proc/3321/task/3321/ for example. Where 3321 is this pid
      // node @ v0.6.10
      if(err || !stat) {
        emitter.emit('fail',path,err);
        return;
      }


      //if i have evented this inode already dont again.
      var fileName = _path.basename(path);
      var fileKey = stat.dev + '-' + stat.ino + '-' + fileName;
      if(inos[fileKey] &amp;&amp; stat.ino) return;
      inos[fileKey] = 1;

      if (first &amp;&amp; stat.isDirectory()) {
        emitter.emit('targetdirectory',path,stat,depth);
        return;
      }

      emitter.emit('path', path, stat,depth);

      var i,name;

      for(var j=0,k=statIs.length;j&lt;k;j++) {
        if(stat[statIs[j][0]]()) {
          emitter.emit(statIs[j][1],path,stat,depth);
          break;
        }
      }
    };

    if(options.sync) {
      var stat,ex;
      try{
        stat = fs.lstatSync(path);
      } catch (e) {
        ex = e;
      }

      statAction(ex,stat);
    } else {
        fs.lstat(path,statAction);
    }
  },readdir = function(path,stat,depth){
    if(!resolved) {
      path = _path.resolve(path);
      resolved = 1;
    }

    if(options.max_depth &amp;&amp; depth &gt;= options.max_depth){
      emitter.emit('maxdepth',path,stat,depth);
      return;
    }

    if(dontTraverse.length){
      for(var i=0;i&lt;dontTraverse.length;++i){
        if(dontTraverse[i] == path) {
          dontTraverse.splice(i,1)
          return;
        }
      }
    }

    job(1);
    var readdirAction = function(err,files) {
      job(-1);
      if (err || !files) {
        //permissions error or invalid files
        emitter.emit('fail',path,err);
        return;
      }

      if(!files.length) {
        // empty directory event.
        emitter.emit('empty',path,stat,depth);
        return;
      }

      if(path == sep) path='';
      for(var i=0,j=files.length;i&lt;j;i++){
        statter(path+sep+files[i],false,(depth||0)+1);
      }

    };


    //use same pattern for sync as async api
    if(options.sync) {
      var e,files;
      try {
          files = fs.readdirSync(path);
      } catch (e) { }

      readdirAction(e,files);
    } else {
      fs.readdir(path,readdirAction);
    }
  };

  if (options.follow_symlinks) {
    var linkAction = function(err,path,depth){
      job(-1);
      //TODO should fail event here on error?
      statter(path,false,depth);
    };

    emitter.on('link',function(path,stat,depth){
      job(1);
      if(options.sync) {
        var lpath,ex;
        try {
          lpath = fs.readlinkSync(path);
        } catch(e) {
          ex = e;
        }
        linkAction(ex,_path.resolve(_path.dirname(path),lpath),depth);

      } else {
        fs.readlink(path,function(err,lpath){
          linkAc ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.walkdir.sync" id="apidoc.element.walkdir.sync">
        function <span class="apidocSignatureSpan">walkdir.</span>sync
        <span class="apidocSignatureSpan">(path, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sync = function (path, options, cb){
  if(typeof options == 'function') cb = options;
  options = options || {};
  options.sync = true;
  return walkdir(path,options,cb);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
emitter.on('file',function(filename,stat){
  console.log('file from emitter: ', filename);
});


//sync with callback

walk.<span class="apidocCodeKeywordSpan">sync</span>('../',function(path,stat){
  console.log('found sync:',path);
});

//sync just need paths

var paths = walk.sync('../');
console.log('found paths sync: ',paths);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.walkdir.walk" id="apidoc.element.walkdir.walk">
        function <span class="apidocSignatureSpan">walkdir.</span>walk
        <span class="apidocSignatureSpan">(path, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function walkdir(path, options, cb){

  if(typeof options == 'function') cb = options;

  options = options || {};

  var fs = options.fs || _fs;

  var emitter = new EventEmitter(),
  dontTraverse = [],
  allPaths = (options.return_object?{}:[]),
  resolved = false,
  inos = {},
  stop = 0,
  pause = null,
  ended = 0,
  jobs=0,
  job = function(value) {
    jobs += value;
    if(value &lt; 1 &amp;&amp; !tick) {
      tick = 1;
      process.nextTick(function(){
        tick = 0;
        if(jobs &lt;= 0 &amp;&amp; !ended) {
          ended = 1;
          emitter.emit('end');
        }
      });
    }
  }, tick = 0;

  emitter.ignore = function(path){
    if(Array.isArray(path)) dontTraverse.push.apply(dontTraverse,path)
    else dontTraverse.push(path)
    return this
  }

  //mapping is stat functions to event names.	
  var statIs = [['isFile','file'],['isDirectory','directory'],['isSymbolicLink','link'],['isSocket','socket'],['isFIFO','fifo'],['
isBlockDevice','blockdevice'],['isCharacterDevice','characterdevice']];

  var statter = function (path,first,depth) {
    job(1);
    var statAction = function fn(err,stat,data) {

      job(-1);
      if(stop) return;

      // in sync mode i found that node will sometimes return a null stat and no error =(
      // this is reproduceable in file descriptors that no longer exist from this process
      // after a readdir on /proc/3321/task/3321/ for example. Where 3321 is this pid
      // node @ v0.6.10
      if(err || !stat) {
        emitter.emit('fail',path,err);
        return;
      }


      //if i have evented this inode already dont again.
      var fileName = _path.basename(path);
      var fileKey = stat.dev + '-' + stat.ino + '-' + fileName;
      if(inos[fileKey] &amp;&amp; stat.ino) return;
      inos[fileKey] = 1;

      if (first &amp;&amp; stat.isDirectory()) {
        emitter.emit('targetdirectory',path,stat,depth);
        return;
      }

      emitter.emit('path', path, stat,depth);

      var i,name;

      for(var j=0,k=statIs.length;j&lt;k;j++) {
        if(stat[statIs[j][0]]()) {
          emitter.emit(statIs[j][1],path,stat,depth);
          break;
        }
      }
    };

    if(options.sync) {
      var stat,ex;
      try{
        stat = fs.lstatSync(path);
      } catch (e) {
        ex = e;
      }

      statAction(ex,stat);
    } else {
        fs.lstat(path,statAction);
    }
  },readdir = function(path,stat,depth){
    if(!resolved) {
      path = _path.resolve(path);
      resolved = 1;
    }

    if(options.max_depth &amp;&amp; depth &gt;= options.max_depth){
      emitter.emit('maxdepth',path,stat,depth);
      return;
    }

    if(dontTraverse.length){
      for(var i=0;i&lt;dontTraverse.length;++i){
        if(dontTraverse[i] == path) {
          dontTraverse.splice(i,1)
          return;
        }
      }
    }

    job(1);
    var readdirAction = function(err,files) {
      job(-1);
      if (err || !files) {
        //permissions error or invalid files
        emitter.emit('fail',path,err);
        return;
      }

      if(!files.length) {
        // empty directory event.
        emitter.emit('empty',path,stat,depth);
        return;
      }

      if(path == sep) path='';
      for(var i=0,j=files.length;i&lt;j;i++){
        statter(path+sep+files[i],false,(depth||0)+1);
      }

    };


    //use same pattern for sync as async api
    if(options.sync) {
      var e,files;
      try {
          files = fs.readdirSync(path);
      } catch (e) { }

      readdirAction(e,files);
    } else {
      fs.readdir(path,readdirAction);
    }
  };

  if (options.follow_symlinks) {
    var linkAction = function(err,path,depth){
      job(-1);
      //TODO should fail event here on error?
      statter(path,false,depth);
    };

    emitter.on('link',function(path,stat,depth){
      job(1);
      if(options.sync) {
        var lpath,ex;
        try {
          lpath = fs.readlinkSync(path);
        } catch(e) {
          ex = e;
        }
        linkAction(ex,_path.resolve(_path.dirname(path),lpath),depth);

      } else {
        fs.readlink(path,function(err,lpath){
          linkAc ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>